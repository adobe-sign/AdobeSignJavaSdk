/*
 * 
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.model.agreements;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import io.swagger.client.model.agreements.AgreementCcInfo;
import io.swagger.client.model.agreements.EmailOption;
import io.swagger.client.model.agreements.ExternalId;
import io.swagger.client.model.agreements.FileInfo;
import io.swagger.client.model.agreements.MergefieldInfo;
import io.swagger.client.model.agreements.OfflineDeviceInfo;
import io.swagger.client.model.agreements.ParticipantSetInfo;
import io.swagger.client.model.agreements.PostSignOption;
import io.swagger.client.model.agreements.SecurityOption;
import io.swagger.client.model.agreements.VaultingInfo;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * AgreementCreationInfo
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2020-11-06T13:23:34.872+11:00")
public class AgreementCreationInfo {
  @SerializedName("groupId")
  private String groupId = null;

  @SerializedName("locale")
  private String locale = null;

  /**
   * The kind of agreement
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    AGREEMENT("AGREEMENT"),
    
    MEGASIGN_CHILD("MEGASIGN_CHILD"),
    
    WIDGET_INSTANCE("WIDGET_INSTANCE");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String text) {
      for (TypeEnum b : TypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("type")
  private TypeEnum type = null;

  @SerializedName("vaultingInfo")
  private VaultingInfo vaultingInfo = null;

  @SerializedName("securityOption")
  private SecurityOption securityOption = null;

  @SerializedName("postSignOption")
  private PostSignOption postSignOption = null;

  @SerializedName("ccs")
  private List<AgreementCcInfo> ccs = null;

  @SerializedName("documentVisibilityEnabled")
  private Boolean documentVisibilityEnabled = null;

  @SerializedName("isDocumentRetentionApplied")
  private Boolean isDocumentRetentionApplied = null;

  @SerializedName("hasSignerIdentityReport")
  private Boolean hasSignerIdentityReport = null;

  @SerializedName("lastEventDate")
  private Date lastEventDate = null;

  @SerializedName("senderEmail")
  private String senderEmail = null;

  @SerializedName("id")
  private String id = null;

  /**
   * The state in which the agreement should land. The state field can only be provided in POST calls, will never get returned in GET /agreements/{ID} and will be ignored if provided in PUT /agreements/{ID} call. The eventual status of the agreement can be obtained from GET /agreements/ID
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    AUTHORING("AUTHORING"),
    
    DRAFT("DRAFT"),
    
    IN_PROCESS("IN_PROCESS");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String text) {
      for (StateEnum b : StateEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return StateEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("state")
  private StateEnum state = null;

  @SerializedName("mergeFieldInfo")
  private List<MergefieldInfo> mergeFieldInfo = null;

  @SerializedName("firstReminderDelay")
  private Integer firstReminderDelay = null;

  @SerializedName("emailOption")
  private EmailOption emailOption = null;

  /**
   * Specifies the type of signature you would like to request - written or e-signature. The possible values are &lt;br&gt; ESIGN : Agreement needs to be signed electronically &lt;br&gt;, WRITTEN : Agreement will be signed using handwritten signature and signed document will be uploaded into the system
   */
  @JsonAdapter(SignatureTypeEnum.Adapter.class)
  public enum SignatureTypeEnum {
    ESIGN("ESIGN"),
    
    WRITTEN("WRITTEN");

    private String value;

    SignatureTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SignatureTypeEnum fromValue(String text) {
      for (SignatureTypeEnum b : SignatureTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<SignatureTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SignatureTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SignatureTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SignatureTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("signatureType")
  private SignatureTypeEnum signatureType = null;

  @SerializedName("externalId")
  private ExternalId externalId = null;

  @SerializedName("message")
  private String message = null;

  @SerializedName("deviceInfo")
  private OfflineDeviceInfo deviceInfo = null;

  @SerializedName("parentId")
  private String parentId = null;

  /**
   * Optional parameter that sets how often you want to send reminders to the participants. If it is not specified, the default frequency set for the account will be used. Should not be provided in offline agreement creation. If provided in PUT as a different value than the current one, an error will be thrown.
   */
  @JsonAdapter(ReminderFrequencyEnum.Adapter.class)
  public enum ReminderFrequencyEnum {
    DAILY_UNTIL_SIGNED("DAILY_UNTIL_SIGNED"),
    
    WEEKDAILY_UNTIL_SIGNED("WEEKDAILY_UNTIL_SIGNED"),
    
    EVERY_OTHER_DAY_UNTIL_SIGNED("EVERY_OTHER_DAY_UNTIL_SIGNED"),
    
    EVERY_THIRD_DAY_UNTIL_SIGNED("EVERY_THIRD_DAY_UNTIL_SIGNED"),
    
    EVERY_FIFTH_DAY_UNTIL_SIGNED("EVERY_FIFTH_DAY_UNTIL_SIGNED"),
    
    WEEKLY_UNTIL_SIGNED("WEEKLY_UNTIL_SIGNED"),
    
    ONCE("ONCE");

    private String value;

    ReminderFrequencyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ReminderFrequencyEnum fromValue(String text) {
      for (ReminderFrequencyEnum b : ReminderFrequencyEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ReminderFrequencyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ReminderFrequencyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ReminderFrequencyEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ReminderFrequencyEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("reminderFrequency")
  private ReminderFrequencyEnum reminderFrequency = null;

  @SerializedName("createdDate")
  private Date createdDate = null;

  @SerializedName("participantSetsInfo")
  private List<ParticipantSetInfo> participantSetsInfo = null;

  @SerializedName("hasFormFieldData")
  private Boolean hasFormFieldData = null;

  @SerializedName("expirationTime")
  private Date expirationTime = null;

  @SerializedName("formFieldLayerTemplates")
  private List<FileInfo> formFieldLayerTemplates = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("fileInfos")
  private List<FileInfo> fileInfos = null;

  @SerializedName("workflowId")
  private String workflowId = null;

  /**
   * This is a server generated attribute which provides the detailed status of an agreement.
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    OUT_FOR_SIGNATURE("OUT_FOR_SIGNATURE"),
    
    OUT_FOR_DELIVERY("OUT_FOR_DELIVERY"),
    
    OUT_FOR_ACCEPTANCE("OUT_FOR_ACCEPTANCE"),
    
    OUT_FOR_FORM_FILLING("OUT_FOR_FORM_FILLING"),
    
    OUT_FOR_APPROVAL("OUT_FOR_APPROVAL"),
    
    AUTHORING("AUTHORING"),
    
    CANCELLED("CANCELLED"),
    
    SIGNED("SIGNED"),
    
    APPROVED("APPROVED"),
    
    DELIVERED("DELIVERED"),
    
    ACCEPTED("ACCEPTED"),
    
    FORM_FILLED("FORM_FILLED"),
    
    EXPIRED("EXPIRED"),
    
    ARCHIVED("ARCHIVED"),
    
    PREFILL("PREFILL"),
    
    WIDGET_WAITING_FOR_VERIFICATION("WIDGET_WAITING_FOR_VERIFICATION"),
    
    DRAFT("DRAFT"),
    
    DOCUMENTS_NOT_YET_PROCESSED("DOCUMENTS_NOT_YET_PROCESSED"),
    
    WAITING_FOR_FAXIN("WAITING_FOR_FAXIN"),
    
    WAITING_FOR_VERIFICATION("WAITING_FOR_VERIFICATION");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String text) {
      for (StatusEnum b : StatusEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return StatusEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("status")
  private StatusEnum status = null;

  public AgreementCreationInfo groupId(String groupId) {
    this.groupId = groupId;
    return this;
  }

   /**
   * The unique identifier of the group to which the agreement belongs to. If not provided during agreement creation, primary group of the creator will be used
   * @return groupId
  **/
  @ApiModelProperty(value = "The unique identifier of the group to which the agreement belongs to. If not provided during agreement creation, primary group of the creator will be used")
  public String getGroupId() {
    return groupId;
  }

  public void setGroupId(String groupId) {
    this.groupId = groupId;
  }

  public AgreementCreationInfo locale(String locale) {
    this.locale = locale;
    return this;
  }

   /**
   * The locale associated with this agreement - specifies the language for the signing page and emails, for example en_US or fr_FR. If none specified, defaults to the language configured for the agreement sender
   * @return locale
  **/
  @ApiModelProperty(value = "The locale associated with this agreement - specifies the language for the signing page and emails, for example en_US or fr_FR. If none specified, defaults to the language configured for the agreement sender")
  public String getLocale() {
    return locale;
  }

  public void setLocale(String locale) {
    this.locale = locale;
  }

  public AgreementCreationInfo type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * The kind of agreement
   * @return type
  **/
  @ApiModelProperty(value = "The kind of agreement")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public AgreementCreationInfo vaultingInfo(VaultingInfo vaultingInfo) {
    this.vaultingInfo = vaultingInfo;
    return this;
  }

   /**
   * Vaulting properties that allows Adobe Sign to securely store documents with a vault provider
   * @return vaultingInfo
  **/
  @ApiModelProperty(value = "Vaulting properties that allows Adobe Sign to securely store documents with a vault provider")
  public VaultingInfo getVaultingInfo() {
    return vaultingInfo;
  }

  public void setVaultingInfo(VaultingInfo vaultingInfo) {
    this.vaultingInfo = vaultingInfo;
  }

  public AgreementCreationInfo securityOption(SecurityOption securityOption) {
    this.securityOption = securityOption;
    return this;
  }

   /**
   * Optional secondary security parameters for the agreement. Should not be provided in offline agreement creation.
   * @return securityOption
  **/
  @ApiModelProperty(value = "Optional secondary security parameters for the agreement. Should not be provided in offline agreement creation.")
  public SecurityOption getSecurityOption() {
    return securityOption;
  }

  public void setSecurityOption(SecurityOption securityOption) {
    this.securityOption = securityOption;
  }

  public AgreementCreationInfo postSignOption(PostSignOption postSignOption) {
    this.postSignOption = postSignOption;
    return this;
  }

   /**
   * URL and associated properties for the success page the user will be taken to after completing the signing process. Should not be provided in offline agreement creation.
   * @return postSignOption
  **/
  @ApiModelProperty(value = "URL and associated properties for the success page the user will be taken to after completing the signing process. Should not be provided in offline agreement creation.")
  public PostSignOption getPostSignOption() {
    return postSignOption;
  }

  public void setPostSignOption(PostSignOption postSignOption) {
    this.postSignOption = postSignOption;
  }

  public AgreementCreationInfo ccs(List<AgreementCcInfo> ccs) {
    this.ccs = ccs;
    return this;
  }

  public AgreementCreationInfo addCcsItem(AgreementCcInfo ccsItem) {
    if (this.ccs == null) {
      this.ccs = new ArrayList<AgreementCcInfo>();
    }
    this.ccs.add(ccsItem);
    return this;
  }

   /**
   * A list of one or more CCs that will be copied in the agreement transaction. The CCs will each receive an email at the beginning of the transaction and also when the final document is signed. The email addresses will also receive a copy of the document, attached as a PDF file. Should not be provided in offline agreement creation.
   * @return ccs
  **/
  @ApiModelProperty(value = "A list of one or more CCs that will be copied in the agreement transaction. The CCs will each receive an email at the beginning of the transaction and also when the final document is signed. The email addresses will also receive a copy of the document, attached as a PDF file. Should not be provided in offline agreement creation.")
  public List<AgreementCcInfo> getCcs() {
    return ccs;
  }

  public void setCcs(List<AgreementCcInfo> ccs) {
    this.ccs = ccs;
  }

  public AgreementCreationInfo documentVisibilityEnabled(Boolean documentVisibilityEnabled) {
    this.documentVisibilityEnabled = documentVisibilityEnabled;
    return this;
  }

   /**
   * If set to true, enable limited document visibility. Should not be provided in offline agreement creation.
   * @return documentVisibilityEnabled
  **/
  @ApiModelProperty(value = "If set to true, enable limited document visibility. Should not be provided in offline agreement creation.")
  public Boolean isDocumentVisibilityEnabled() {
    return documentVisibilityEnabled;
  }

  public void setDocumentVisibilityEnabled(Boolean documentVisibilityEnabled) {
    this.documentVisibilityEnabled = documentVisibilityEnabled;
  }

  public AgreementCreationInfo isDocumentRetentionApplied(Boolean isDocumentRetentionApplied) {
    this.isDocumentRetentionApplied = isDocumentRetentionApplied;
    return this;
  }

   /**
   * Is document retention applied for this resource.  If provided in POST or PUT, it will simply be ignored.
   * @return isDocumentRetentionApplied
  **/
  @ApiModelProperty(value = "Is document retention applied for this resource.  If provided in POST or PUT, it will simply be ignored.")
  public Boolean isIsDocumentRetentionApplied() {
    return isDocumentRetentionApplied;
  }

  public void setIsDocumentRetentionApplied(Boolean isDocumentRetentionApplied) {
    this.isDocumentRetentionApplied = isDocumentRetentionApplied;
  }

  public AgreementCreationInfo hasSignerIdentityReport(Boolean hasSignerIdentityReport) {
    this.hasSignerIdentityReport = hasSignerIdentityReport;
    return this;
  }

   /**
   * True if agreement has signer identity report available.  If provided in POST or PUT, it will simply be ignored.
   * @return hasSignerIdentityReport
  **/
  @ApiModelProperty(value = "True if agreement has signer identity report available.  If provided in POST or PUT, it will simply be ignored.")
  public Boolean isHasSignerIdentityReport() {
    return hasSignerIdentityReport;
  }

  public void setHasSignerIdentityReport(Boolean hasSignerIdentityReport) {
    this.hasSignerIdentityReport = hasSignerIdentityReport;
  }

  public AgreementCreationInfo lastEventDate(Date lastEventDate) {
    this.lastEventDate = lastEventDate;
    return this;
  }

   /**
   * The date of the last event that occurred for this agreement. Format would be yyyy-MM-dd&#39;T&#39;HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time
   * @return lastEventDate
  **/
  @ApiModelProperty(value = "The date of the last event that occurred for this agreement. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time")
  public Date getLastEventDate() {
    return lastEventDate;
  }

  public void setLastEventDate(Date lastEventDate) {
    this.lastEventDate = lastEventDate;
  }

  public AgreementCreationInfo senderEmail(String senderEmail) {
    this.senderEmail = senderEmail;
    return this;
  }

   /**
   * Email of agreement sender. Only provided in GET. Can not be provided in POST/PUT request. If provided in POST/PUT, it will be ignored
   * @return senderEmail
  **/
  @ApiModelProperty(value = "Email of agreement sender. Only provided in GET. Can not be provided in POST/PUT request. If provided in POST/PUT, it will be ignored")
  public String getSenderEmail() {
    return senderEmail;
  }

  public void setSenderEmail(String senderEmail) {
    this.senderEmail = senderEmail;
  }

  public AgreementCreationInfo id(String id) {
    this.id = id;
    return this;
  }

   /**
   * The unique identifier of the agreement.If provided in POST, it will simply be ignored
   * @return id
  **/
  @ApiModelProperty(value = "The unique identifier of the agreement.If provided in POST, it will simply be ignored")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public AgreementCreationInfo state(StateEnum state) {
    this.state = state;
    return this;
  }

   /**
   * The state in which the agreement should land. The state field can only be provided in POST calls, will never get returned in GET /agreements/{ID} and will be ignored if provided in PUT /agreements/{ID} call. The eventual status of the agreement can be obtained from GET /agreements/ID
   * @return state
  **/
  @ApiModelProperty(value = "The state in which the agreement should land. The state field can only be provided in POST calls, will never get returned in GET /agreements/{ID} and will be ignored if provided in PUT /agreements/{ID} call. The eventual status of the agreement can be obtained from GET /agreements/ID")
  public StateEnum getState() {
    return state;
  }

  public void setState(StateEnum state) {
    this.state = state;
  }

  public AgreementCreationInfo mergeFieldInfo(List<MergefieldInfo> mergeFieldInfo) {
    this.mergeFieldInfo = mergeFieldInfo;
    return this;
  }

  public AgreementCreationInfo addMergeFieldInfoItem(MergefieldInfo mergeFieldInfoItem) {
    if (this.mergeFieldInfo == null) {
      this.mergeFieldInfo = new ArrayList<MergefieldInfo>();
    }
    this.mergeFieldInfo.add(mergeFieldInfoItem);
    return this;
  }

   /**
   * Optional default values for fields to merge into the document. The values will be presented to the signers for editable fields; for read-only fields the provided values will not be editable during the signing process. Merging data into fields is currently not supported when used with libraryDocumentId or libraryDocumentName. Only file and url are currently supported
   * @return mergeFieldInfo
  **/
  @ApiModelProperty(value = "Optional default values for fields to merge into the document. The values will be presented to the signers for editable fields; for read-only fields the provided values will not be editable during the signing process. Merging data into fields is currently not supported when used with libraryDocumentId or libraryDocumentName. Only file and url are currently supported")
  public List<MergefieldInfo> getMergeFieldInfo() {
    return mergeFieldInfo;
  }

  public void setMergeFieldInfo(List<MergefieldInfo> mergeFieldInfo) {
    this.mergeFieldInfo = mergeFieldInfo;
  }

  public AgreementCreationInfo firstReminderDelay(Integer firstReminderDelay) {
    this.firstReminderDelay = firstReminderDelay;
    return this;
  }

   /**
   * Integer which specifies the delay in hours before sending the first reminder.&lt;br&gt;This is an optional field. The minimum value allowed is 1 hour and the maximum value can’t be more than the difference of agreement creation and expiry time of the agreement in hours.&lt;br&gt;If this is not specified but the reminder frequency is specified, then the first reminder will be sent based on frequency.&lt;br&gt;i.e. if the reminder is created with frequency specified as daily, the firstReminderDelay will be 24 hours. Should not be provided in offline agreement creation.
   * @return firstReminderDelay
  **/
  @ApiModelProperty(value = "Integer which specifies the delay in hours before sending the first reminder.<br>This is an optional field. The minimum value allowed is 1 hour and the maximum value can’t be more than the difference of agreement creation and expiry time of the agreement in hours.<br>If this is not specified but the reminder frequency is specified, then the first reminder will be sent based on frequency.<br>i.e. if the reminder is created with frequency specified as daily, the firstReminderDelay will be 24 hours. Should not be provided in offline agreement creation.")
  public Integer getFirstReminderDelay() {
    return firstReminderDelay;
  }

  public void setFirstReminderDelay(Integer firstReminderDelay) {
    this.firstReminderDelay = firstReminderDelay;
  }

  public AgreementCreationInfo emailOption(EmailOption emailOption) {
    this.emailOption = emailOption;
    return this;
  }

   /**
   * Email configurations for the agreement. Should not be provided in offline agreement creation or when updating a non draft agreement.
   * @return emailOption
  **/
  @ApiModelProperty(value = "Email configurations for the agreement. Should not be provided in offline agreement creation or when updating a non draft agreement.")
  public EmailOption getEmailOption() {
    return emailOption;
  }

  public void setEmailOption(EmailOption emailOption) {
    this.emailOption = emailOption;
  }

  public AgreementCreationInfo signatureType(SignatureTypeEnum signatureType) {
    this.signatureType = signatureType;
    return this;
  }

   /**
   * Specifies the type of signature you would like to request - written or e-signature. The possible values are &lt;br&gt; ESIGN : Agreement needs to be signed electronically &lt;br&gt;, WRITTEN : Agreement will be signed using handwritten signature and signed document will be uploaded into the system
   * @return signatureType
  **/
  @ApiModelProperty(value = "Specifies the type of signature you would like to request - written or e-signature. The possible values are <br> ESIGN : Agreement needs to be signed electronically <br>, WRITTEN : Agreement will be signed using handwritten signature and signed document will be uploaded into the system")
  public SignatureTypeEnum getSignatureType() {
    return signatureType;
  }

  public void setSignatureType(SignatureTypeEnum signatureType) {
    this.signatureType = signatureType;
  }

  public AgreementCreationInfo externalId(ExternalId externalId) {
    this.externalId = externalId;
    return this;
  }

   /**
   * An arbitrary value from your system, which can be specified at sending time and then later returned or queried. Should not be provided in offline agreement creation.
   * @return externalId
  **/
  @ApiModelProperty(value = "An arbitrary value from your system, which can be specified at sending time and then later returned or queried. Should not be provided in offline agreement creation.")
  public ExternalId getExternalId() {
    return externalId;
  }

  public void setExternalId(ExternalId externalId) {
    this.externalId = externalId;
  }

  public AgreementCreationInfo message(String message) {
    this.message = message;
    return this;
  }

   /**
   * An optional message to the participants, describing what is being sent or why their signature is required
   * @return message
  **/
  @ApiModelProperty(value = "An optional message to the participants, describing what is being sent or why their signature is required")
  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }

  public AgreementCreationInfo deviceInfo(OfflineDeviceInfo deviceInfo) {
    this.deviceInfo = deviceInfo;
    return this;
  }

   /**
   * Device info of the offline device. It should only be provided in case of offline agreement creation.
   * @return deviceInfo
  **/
  @ApiModelProperty(value = "Device info of the offline device. It should only be provided in case of offline agreement creation.")
  public OfflineDeviceInfo getDeviceInfo() {
    return deviceInfo;
  }

  public void setDeviceInfo(OfflineDeviceInfo deviceInfo) {
    this.deviceInfo = deviceInfo;
  }

  public AgreementCreationInfo parentId(String parentId) {
    this.parentId = parentId;
    return this;
  }

   /**
   * The parent id of a megaSign child *OR* the originating id of a widget agreement instance
   * @return parentId
  **/
  @ApiModelProperty(value = "The parent id of a megaSign child *OR* the originating id of a widget agreement instance")
  public String getParentId() {
    return parentId;
  }

  public void setParentId(String parentId) {
    this.parentId = parentId;
  }

  public AgreementCreationInfo reminderFrequency(ReminderFrequencyEnum reminderFrequency) {
    this.reminderFrequency = reminderFrequency;
    return this;
  }

   /**
   * Optional parameter that sets how often you want to send reminders to the participants. If it is not specified, the default frequency set for the account will be used. Should not be provided in offline agreement creation. If provided in PUT as a different value than the current one, an error will be thrown.
   * @return reminderFrequency
  **/
  @ApiModelProperty(value = "Optional parameter that sets how often you want to send reminders to the participants. If it is not specified, the default frequency set for the account will be used. Should not be provided in offline agreement creation. If provided in PUT as a different value than the current one, an error will be thrown.")
  public ReminderFrequencyEnum getReminderFrequency() {
    return reminderFrequency;
  }

  public void setReminderFrequency(ReminderFrequencyEnum reminderFrequency) {
    this.reminderFrequency = reminderFrequency;
  }

  public AgreementCreationInfo createdDate(Date createdDate) {
    this.createdDate = createdDate;
    return this;
  }

   /**
   * Date when agreement was created. This is a server generated attributed and can not be provided in POST/PUT calls. Format would be yyyy-MM-dd&#39;T&#39;HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time
   * @return createdDate
  **/
  @ApiModelProperty(value = "Date when agreement was created. This is a server generated attributed and can not be provided in POST/PUT calls. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time")
  public Date getCreatedDate() {
    return createdDate;
  }

  public void setCreatedDate(Date createdDate) {
    this.createdDate = createdDate;
  }

  public AgreementCreationInfo participantSetsInfo(List<ParticipantSetInfo> participantSetsInfo) {
    this.participantSetsInfo = participantSetsInfo;
    return this;
  }

  public AgreementCreationInfo addParticipantSetsInfoItem(ParticipantSetInfo participantSetsInfoItem) {
    if (this.participantSetsInfo == null) {
      this.participantSetsInfo = new ArrayList<ParticipantSetInfo>();
    }
    this.participantSetsInfo.add(participantSetsInfoItem);
    return this;
  }

   /**
   * A list of one or more participant set. A participant set may have one or more participant. If any member of the participant set takes the action that has been assigned to the set(Sign/Approve/Acknowledge etc), the action is considered as the action taken by whole participation set. For regular (non-MegaSign) documents, there is no limit on the number of electronic signatures in a single document. Written signatures are limited to four per document
   * @return participantSetsInfo
  **/
  @ApiModelProperty(value = "A list of one or more participant set. A participant set may have one or more participant. If any member of the participant set takes the action that has been assigned to the set(Sign/Approve/Acknowledge etc), the action is considered as the action taken by whole participation set. For regular (non-MegaSign) documents, there is no limit on the number of electronic signatures in a single document. Written signatures are limited to four per document")
  public List<ParticipantSetInfo> getParticipantSetsInfo() {
    return participantSetsInfo;
  }

  public void setParticipantSetsInfo(List<ParticipantSetInfo> participantSetsInfo) {
    this.participantSetsInfo = participantSetsInfo;
  }

  public AgreementCreationInfo hasFormFieldData(Boolean hasFormFieldData) {
    this.hasFormFieldData = hasFormFieldData;
    return this;
  }

   /**
   * True if form field data is present.  If provided in POST or PUT, it will simply be ignored.
   * @return hasFormFieldData
  **/
  @ApiModelProperty(value = "True if form field data is present.  If provided in POST or PUT, it will simply be ignored.")
  public Boolean isHasFormFieldData() {
    return hasFormFieldData;
  }

  public void setHasFormFieldData(Boolean hasFormFieldData) {
    this.hasFormFieldData = hasFormFieldData;
  }

  public AgreementCreationInfo expirationTime(Date expirationTime) {
    this.expirationTime = expirationTime;
    return this;
  }

   /**
   * Time after which Agreement expires and needs to be signed before it. Format should be yyyy-MM-dd&#39;T&#39;HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time. Should not be provided in offline agreement creation.
   * @return expirationTime
  **/
  @ApiModelProperty(value = "Time after which Agreement expires and needs to be signed before it. Format should be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time. Should not be provided in offline agreement creation.")
  public Date getExpirationTime() {
    return expirationTime;
  }

  public void setExpirationTime(Date expirationTime) {
    this.expirationTime = expirationTime;
  }

  public AgreementCreationInfo formFieldLayerTemplates(List<FileInfo> formFieldLayerTemplates) {
    this.formFieldLayerTemplates = formFieldLayerTemplates;
    return this;
  }

  public AgreementCreationInfo addFormFieldLayerTemplatesItem(FileInfo formFieldLayerTemplatesItem) {
    if (this.formFieldLayerTemplates == null) {
      this.formFieldLayerTemplates = new ArrayList<FileInfo>();
    }
    this.formFieldLayerTemplates.add(formFieldLayerTemplatesItem);
    return this;
  }

   /**
   * Specifies the form field layer template or source of form fields to apply on the files in this transaction. If specified, the FileInfo for this parameter must refer to a form field layer template via libraryDocumentId or libraryDocumentName, or if specified via transientDocumentId or documentURL, it must be of a supported file type. Note: Only one of the four parameters in every FileInfo object must be specified
   * @return formFieldLayerTemplates
  **/
  @ApiModelProperty(value = "Specifies the form field layer template or source of form fields to apply on the files in this transaction. If specified, the FileInfo for this parameter must refer to a form field layer template via libraryDocumentId or libraryDocumentName, or if specified via transientDocumentId or documentURL, it must be of a supported file type. Note: Only one of the four parameters in every FileInfo object must be specified")
  public List<FileInfo> getFormFieldLayerTemplates() {
    return formFieldLayerTemplates;
  }

  public void setFormFieldLayerTemplates(List<FileInfo> formFieldLayerTemplates) {
    this.formFieldLayerTemplates = formFieldLayerTemplates;
  }

  public AgreementCreationInfo name(String name) {
    this.name = name;
    return this;
  }

   /**
   * The name of the agreement that will be used to identify it, in emails, website and other places
   * @return name
  **/
  @ApiModelProperty(value = "The name of the agreement that will be used to identify it, in emails, website and other places")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public AgreementCreationInfo fileInfos(List<FileInfo> fileInfos) {
    this.fileInfos = fileInfos;
    return this;
  }

  public AgreementCreationInfo addFileInfosItem(FileInfo fileInfosItem) {
    if (this.fileInfos == null) {
      this.fileInfos = new ArrayList<FileInfo>();
    }
    this.fileInfos.add(fileInfosItem);
    return this;
  }

   /**
   * A list of one or more files (or references to files) that will be sent out for signature. If more than one file is provided, they will be combined into one PDF before being sent out. Note: Only one of the four parameters in every FileInfo object must be specified
   * @return fileInfos
  **/
  @ApiModelProperty(value = "A list of one or more files (or references to files) that will be sent out for signature. If more than one file is provided, they will be combined into one PDF before being sent out. Note: Only one of the four parameters in every FileInfo object must be specified")
  public List<FileInfo> getFileInfos() {
    return fileInfos;
  }

  public void setFileInfos(List<FileInfo> fileInfos) {
    this.fileInfos = fileInfos;
  }

  public AgreementCreationInfo workflowId(String workflowId) {
    this.workflowId = workflowId;
    return this;
  }

   /**
   * The identifier of custom workflow which defines the routing path of an agreement. Should not be provided in offline agreement creation.
   * @return workflowId
  **/
  @ApiModelProperty(value = "The identifier of custom workflow which defines the routing path of an agreement. Should not be provided in offline agreement creation.")
  public String getWorkflowId() {
    return workflowId;
  }

  public void setWorkflowId(String workflowId) {
    this.workflowId = workflowId;
  }

  public AgreementCreationInfo status(StatusEnum status) {
    this.status = status;
    return this;
  }

   /**
   * This is a server generated attribute which provides the detailed status of an agreement.
   * @return status
  **/
  @ApiModelProperty(value = "This is a server generated attribute which provides the detailed status of an agreement.")
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(StatusEnum status) {
    this.status = status;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AgreementCreationInfo agreementCreationInfo = (AgreementCreationInfo) o;
    return Objects.equals(this.groupId, agreementCreationInfo.groupId) &&
        Objects.equals(this.locale, agreementCreationInfo.locale) &&
        Objects.equals(this.type, agreementCreationInfo.type) &&
        Objects.equals(this.vaultingInfo, agreementCreationInfo.vaultingInfo) &&
        Objects.equals(this.securityOption, agreementCreationInfo.securityOption) &&
        Objects.equals(this.postSignOption, agreementCreationInfo.postSignOption) &&
        Objects.equals(this.ccs, agreementCreationInfo.ccs) &&
        Objects.equals(this.documentVisibilityEnabled, agreementCreationInfo.documentVisibilityEnabled) &&
        Objects.equals(this.isDocumentRetentionApplied, agreementCreationInfo.isDocumentRetentionApplied) &&
        Objects.equals(this.hasSignerIdentityReport, agreementCreationInfo.hasSignerIdentityReport) &&
        Objects.equals(this.lastEventDate, agreementCreationInfo.lastEventDate) &&
        Objects.equals(this.senderEmail, agreementCreationInfo.senderEmail) &&
        Objects.equals(this.id, agreementCreationInfo.id) &&
        Objects.equals(this.state, agreementCreationInfo.state) &&
        Objects.equals(this.mergeFieldInfo, agreementCreationInfo.mergeFieldInfo) &&
        Objects.equals(this.firstReminderDelay, agreementCreationInfo.firstReminderDelay) &&
        Objects.equals(this.emailOption, agreementCreationInfo.emailOption) &&
        Objects.equals(this.signatureType, agreementCreationInfo.signatureType) &&
        Objects.equals(this.externalId, agreementCreationInfo.externalId) &&
        Objects.equals(this.message, agreementCreationInfo.message) &&
        Objects.equals(this.deviceInfo, agreementCreationInfo.deviceInfo) &&
        Objects.equals(this.parentId, agreementCreationInfo.parentId) &&
        Objects.equals(this.reminderFrequency, agreementCreationInfo.reminderFrequency) &&
        Objects.equals(this.createdDate, agreementCreationInfo.createdDate) &&
        Objects.equals(this.participantSetsInfo, agreementCreationInfo.participantSetsInfo) &&
        Objects.equals(this.hasFormFieldData, agreementCreationInfo.hasFormFieldData) &&
        Objects.equals(this.expirationTime, agreementCreationInfo.expirationTime) &&
        Objects.equals(this.formFieldLayerTemplates, agreementCreationInfo.formFieldLayerTemplates) &&
        Objects.equals(this.name, agreementCreationInfo.name) &&
        Objects.equals(this.fileInfos, agreementCreationInfo.fileInfos) &&
        Objects.equals(this.workflowId, agreementCreationInfo.workflowId) &&
        Objects.equals(this.status, agreementCreationInfo.status);
  }

  @Override
  public int hashCode() {
    return Objects.hash(groupId, locale, type, vaultingInfo, securityOption, postSignOption, ccs, documentVisibilityEnabled, isDocumentRetentionApplied, hasSignerIdentityReport, lastEventDate, senderEmail, id, state, mergeFieldInfo, firstReminderDelay, emailOption, signatureType, externalId, message, deviceInfo, parentId, reminderFrequency, createdDate, participantSetsInfo, hasFormFieldData, expirationTime, formFieldLayerTemplates, name, fileInfos, workflowId, status);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AgreementCreationInfo {\n");
    
    sb.append("    groupId: ").append(toIndentedString(groupId)).append("\n");
    sb.append("    locale: ").append(toIndentedString(locale)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    vaultingInfo: ").append(toIndentedString(vaultingInfo)).append("\n");
    sb.append("    securityOption: ").append(toIndentedString(securityOption)).append("\n");
    sb.append("    postSignOption: ").append(toIndentedString(postSignOption)).append("\n");
    sb.append("    ccs: ").append(toIndentedString(ccs)).append("\n");
    sb.append("    documentVisibilityEnabled: ").append(toIndentedString(documentVisibilityEnabled)).append("\n");
    sb.append("    isDocumentRetentionApplied: ").append(toIndentedString(isDocumentRetentionApplied)).append("\n");
    sb.append("    hasSignerIdentityReport: ").append(toIndentedString(hasSignerIdentityReport)).append("\n");
    sb.append("    lastEventDate: ").append(toIndentedString(lastEventDate)).append("\n");
    sb.append("    senderEmail: ").append(toIndentedString(senderEmail)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    mergeFieldInfo: ").append(toIndentedString(mergeFieldInfo)).append("\n");
    sb.append("    firstReminderDelay: ").append(toIndentedString(firstReminderDelay)).append("\n");
    sb.append("    emailOption: ").append(toIndentedString(emailOption)).append("\n");
    sb.append("    signatureType: ").append(toIndentedString(signatureType)).append("\n");
    sb.append("    externalId: ").append(toIndentedString(externalId)).append("\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\n");
    sb.append("    deviceInfo: ").append(toIndentedString(deviceInfo)).append("\n");
    sb.append("    parentId: ").append(toIndentedString(parentId)).append("\n");
    sb.append("    reminderFrequency: ").append(toIndentedString(reminderFrequency)).append("\n");
    sb.append("    createdDate: ").append(toIndentedString(createdDate)).append("\n");
    sb.append("    participantSetsInfo: ").append(toIndentedString(participantSetsInfo)).append("\n");
    sb.append("    hasFormFieldData: ").append(toIndentedString(hasFormFieldData)).append("\n");
    sb.append("    expirationTime: ").append(toIndentedString(expirationTime)).append("\n");
    sb.append("    formFieldLayerTemplates: ").append(toIndentedString(formFieldLayerTemplates)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    fileInfos: ").append(toIndentedString(fileInfos)).append("\n");
    sb.append("    workflowId: ").append(toIndentedString(workflowId)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

